# API diff as generated by cabal-diff with minor edits.
# ~~~ means deprecated module
# ~~ means deprecated symbol

#----------------------------
# Changes from 0.8.0 to 0.8.1
#----------------------------

@@@ Streamly.FileSystem.Handle
++ getChunk :: MonadIO m => Int -> Handle -> m (Array Word8)
++ putChunk :: (MonadIO m, Storable a) => Handle -> Array a -> m ()

#----------------------------
# Changes from 0.7.3 to 0.8.0
#----------------------------

# Deprecated, merged into Streamly.Prelude
~~~ Streamly
# Fixity changes
++ infixr 6 `ahead`
++ infixr 6 `async`
++ infixr 6 `parallel`
++ infixr 6 `serial`
++ infixr 6 `wAsync`
++ infixr 6 `wSerial`

# Added
@@@ Streamly.Console.Stdio

# Deprecated, renamed
~~~ Streamly.Memory.Array
@@@ Streamly.Data.Array.Foreign

# Moved from Streamly.Memory.Array
++ data Array a
++ fromList :: Storable a => [a] -> Array a
++ fromListN :: Storable a => Int -> [a] -> Array a
++ length :: forall a. Storable a => Array a -> Int
++ read :: forall m a. (Monad m, Storable a) => Unfold m (Array a) a
++ toList :: Storable a => Array a -> [a]
++ write :: forall m a. (MonadIO m, Storable a) => Fold m a (Array a)
++ writeN :: forall m a. (MonadIO m, Storable a) => Int -> Fold m a (Array a)

# Added
++ asBytes :: Array a -> Array Word8
++ cast :: forall a b. Storable b => Array a -> Maybe (Array b)
++ getIndex :: Storable a => Array a -> Int -> Maybe a
++ readRev :: forall m a. (Monad m, Storable a) => Unfold m (Array a) a
++ writeLastN :: (Storable a, MonadIO m) => Int -> Fold m a (Array a)

@@@ Streamly.Data.Fold
# Signature changed
 - product :: (Monad m, Num a) => Fold m a a
 + product :: (Monad m, Num a, Eq a) => Fold m a a

# Removed (Moved to the Streamly.Data.Fold.Tee module)
-- instance (Monad m, Floating b) => Floating (Fold m a b)
-- instance (Monad m, GHC.Num.Num b) => GHC.Num.Num (Fold m a b)
-- instance (Monad m, GHC.Real.Fractional b) => GHC.Real.Fractional (Fold m a b)
-- instance (Semigroup b, Monad m) => Semigroup (Fold m a b)
-- instance (Semigroup b, Monoid b, Monad m) => Monoid (Fold m a b)
-- instance Applicative m => Applicative (Fold m a)

# Renamed
~~ mapM :: Monad m => (b -> m c) -> Fold m a b -> Fold m a c
++ rmapM :: Monad m => (b -> m c) -> Fold m a b -> Fold m a c

# Deprecated
~~ sequence :: Monad m => Fold m a (m b) -> Fold m a b

# Added
++ catMaybes :: Monad m => Fold m a b -> Fold m (Maybe a) b
++ chunksOf :: Monad m => Int -> Fold m a b -> Fold m b c -> Fold m a c
++ concatMap :: Monad m => (b -> Fold m a c) -> Fold m a b -> Fold m a c
++ filter :: Monad m => (a -> Bool) -> Fold m a r -> Fold m a r
++ filterM :: Monad m => (a -> m Bool) -> Fold m a r -> Fold m a r
++ foldl' :: Monad m => (b -> a -> b) -> b -> Fold m a b
++ foldlM' :: Monad m => (b -> a -> m b) -> m b -> Fold m a b
++ foldr :: Monad m => (a -> b -> b) -> b -> Fold m a b
++ lmap :: (a -> b) -> Fold m b r -> Fold m a r
++ lmapM :: Monad m => (a -> m b) -> Fold m b r -> Fold m a r
++ many :: Monad m => Fold m a b -> Fold m b c -> Fold m a c
++ mapMaybe :: Monad m => (a -> Maybe b) -> Fold m b r -> Fold m a r
++ rollingHash :: (Monad m, Enum a) => Fold m a Int64
++ rollingHashWithSalt :: (Monad m, Enum a) => Int64 -> Fold m a Int64
++ sconcat :: (Monad m, Semigroup a) => a -> Fold m a a
++ serialWith :: Monad m => (a -> b -> c) -> Fold m x a -> Fold m x b -> Fold m x c
++ take :: Monad m => Int -> Fold m a b -> Fold m a b
++ takeEndBy :: Monad m => (a -> Bool) -> Fold m a b -> Fold m a b
++ takeEndBy_ :: Monad m => (a -> Bool) -> Fold m a b -> Fold m a b
++ teeWith :: Monad m => (a -> b -> c) -> Fold m x a -> Fold m x b -> Fold m x c
++ toListRev :: Monad m => Fold m a [a]

# Added
@@@ Streamly.Data.Fold.Tee

@@@ Streamly.Data.Unfold
# Added
++ crossWith :: Monad m => (b -> c -> d) -> Unfold m a b -> Unfold m a c -> Unfold m a d
++ drop :: Monad m => Int -> Unfold m a b -> Unfold m a b
++ dropWhile :: Monad m => (b -> Bool) -> Unfold m a b -> Unfold m a b
++ dropWhileM :: Monad m => (b -> m Bool) -> Unfold m a b -> Unfold m a b
++ filter :: Monad m => (b -> Bool) -> Unfold m a b -> Unfold m a b
++ filterM :: Monad m => (b -> m Bool) -> Unfold m a b -> Unfold m a b
++ fromList :: Monad m => Unfold m [a] a
++ fromListM :: Monad m => Unfold m [m a] a
++ fromStream :: (IsStream t, Monad m) => Unfold m (t m a) a
++ function :: Applicative m => (a -> b) -> Unfold m a b
++ functionM :: Applicative m => (a -> m b) -> Unfold m a b
++ iterateM :: Monad m => (a -> m a) -> Unfold m (m a) a
++ lmap :: (a -> c) -> Unfold m c b -> Unfold m a b
++ lmapM :: Monad m => (a -> m c) -> Unfold m c b -> Unfold m a b
++ many :: Monad m => Unfold m a b -> Unfold m b c -> Unfold m a c
++ mapM :: Monad m => (b -> m c) -> Unfold m a b -> Unfold m a c
++ repeatM :: Monad m => Unfold m (m a) a
++ replicateM :: Monad m => Int -> Unfold m (m a) a
++ take :: Monad m => Int -> Unfold m a b -> Unfold m a b
++ takeWhile :: Monad m => (b -> Bool) -> Unfold m a b -> Unfold m a b
++ takeWhileM :: Monad m => (b -> m Bool) -> Unfold m a b -> Unfold m a b
++ unfoldr :: Applicative m => (a -> Maybe (b, a)) -> Unfold m a b
++ unfoldrM :: Applicative m => (a -> m (Maybe (b, a))) -> Unfold m a b
++ zipWith :: Monad m => (b -> c -> d) -> Unfold m a b -> Unfold m a c -> Unfold m a d

# Deprecated, renamed to Streamly.Unicode.Stream
~~~ Streamly.Data.Unicode.Stream

@@@ Streamly.Network.Socket
# Added
++ forSocketM :: (MonadMask m, MonadIO m) => (Socket -> m ()) -> Socket -> m ()
++ readChunk :: Int -> Socket -> IO (Array Word8)
++ writeChunk :: Storable a => Socket -> Array a -> IO ()
++ writeChunksWithBufferOf :: (MonadIO m, Storable a) => Int -> Socket -> Fold m (Array a) ()

@@@ Streamly.Prelude
# Signature changed
 - after :: (IsStream t, Monad m) => m b -> t m a -> t m a
 + after :: (IsStream t, MonadIO m, MonadBaseControl IO m) => m b -> t m a -> t m a
 - bracket :: (IsStream t, MonadCatch m) => m b -> (b -> m c) -> (b -> t m a) -> t m a
 + bracket :: (IsStream t, MonadAsync m, MonadCatch m) => m b -> (b -> m c) -> (b -> t m a) -> t m a
 - concatMapWith :: IsStream t => (forall c. t m c -> t m c -> t m c) -> (a -> t m b) -> t m a -> t m b
 + concatMapWith :: IsStream t => (t m b -> t m b -> t m b) -> (a -> t m b) -> t m a -> t m b
 - finally :: (IsStream t, MonadCatch m) => m b -> t m a -> t m a
 + finally :: (IsStream t, MonadAsync m, MonadCatch m) => m b -> t m a -> t m a
 - foldlM' :: Monad m => (b -> a -> m b) -> b -> SerialT m a -> m b
 + foldlM' :: Monad m => (b -> a -> m b) -> m b -> SerialT m a -> m b
 - postscanlM' :: (IsStream t, Monad m) => (b -> a -> m b) -> b -> t m a -> t m b
 + postscanlM' :: (IsStream t, Monad m) => (b -> a -> m b) -> m b -> t m a -> t m b
 - scanlM' :: (IsStream t, Monad m) => (b -> a -> m b) -> b -> t m a -> t m b
 + scanlM' :: (IsStream t, Monad m) => (b -> a -> m b) -> m b -> t m a -> t m b

# Renamed
~~ yieldM :: (Monad m, IsStream t) => m a -> t m a
++ fromEffect :: (Monad m, IsStream t) => m a -> t m a
~~ yield :: IsStream t => a -> t m a
++ fromPure :: IsStream t => a -> t m a
~~ concatUnfold :: (IsStream t, Monad m) => Unfold m a b -> t m a -> t m b
++ unfoldMany :: (IsStream t, Monad m) => Unfold m a b -> t m a -> t m b

# Moved from "Streamly" module
## Fixity change
++ infixr 6 `ahead`
++ infixr 6 `async`
++ infixr 6 `parallel`
++ infixr 6 `serial`
++ infixr 6 `wAsync`
++ infixr 6 `wSerial`
## Renamed
~~ foldWith :: (IsStream t, Foldable f) => (t m a -> t m a -> t m a) -> f (t m a) -> t m a
++ concatFoldableWith :: (IsStream t, Foldable f) => (t m a -> t m a -> t m a) -> f (t m a) -> t m a
~~ forEachWith :: (IsStream t, Foldable f) => (t m b -> t m b -> t m b) -> f a -> (a -> t m b) -> t m b
++ concatForFoldableWith :: (IsStream t, Foldable f) => (t m b -> t m b -> t m b) -> f a -> (a -> t m b) -> t m b
~~ foldMapWith :: (IsStream t, Foldable f) => (t m b -> t m b -> t m b) -> (a -> t m b) -> f a -> t m b
++ concatMapFoldableWith :: (IsStream t, Foldable f) => (t m b -> t m b -> t m b) -> (a -> t m b) -> f a -> t m b
~~ aheadly :: IsStream t => AheadT m a -> t m a
++ fromAhead :: IsStream t => AheadT m a -> t m a
~~ asyncly :: IsStream t => AsyncT m a -> t m a
++ fromAsync :: IsStream t => AsyncT m a -> t m a
~~ parallely :: IsStream t => ParallelT m a -> t m a
++ fromParallel :: IsStream t => ParallelT m a -> t m a
~~ serially :: IsStream t => SerialT m a -> t m a
++ fromSerial :: IsStream t => SerialT m a -> t m a
~~ wAsyncly :: IsStream t => WAsyncT m a -> t m a
++ fromWAsync :: IsStream t => WAsyncT m a -> t m a
~~ wSerially :: IsStream t => WSerialT m a -> t m a
++ fromWSerial :: IsStream t => WSerialT m a -> t m a
~~ zipAsyncly :: IsStream t => ZipAsyncM m a -> t m a
++ fromZipAsync :: IsStream t => ZipAsyncM m a -> t m a
~~ zipSerially :: IsStream t => ZipSerialM m a -> t m a
++ fromZipSerial :: IsStream t => ZipSerialM m a -> t m a
## unchanged
++ class (forall m a. MonadAsync m => Semigroup (t m a), forall m a. MonadAsync m => Monoid (t m a), forall m. Monad m => Functor (t m), forall m. MonadAsync m => Applicative (t m)) => IsStream t
++ data AheadT m a
++ data AsyncT m a
++ data ParallelT m a
++ data Rate Rate :: Double -> Double -> Double -> Int -> Rate
++ data SerialT m a
++ data WAsyncT m a
++ data WSerialT m a
++ data ZipAsyncM m a
++ data ZipSerialM m a
++ type Ahead = AheadT IO
++ type Async = AsyncT IO
++ type MonadAsync m = (MonadIO m, MonadBaseControl IO m, MonadThrow m)
++ type Parallel = ParallelT IO
++ type Serial = SerialT IO
++ type WAsync = WAsyncT IO
++ type WSerial = WSerialT IO
++ type ZipAsync = ZipAsyncM IO
++ type ZipSerial = ZipSerialM IO
++ (|$) :: (IsStream t, MonadAsync m) => (t m a -> t m b) -> t m a -> t m b
++ (|$.) :: (IsStream t, MonadAsync m) => (t m a -> m b) -> t m a -> m b
++ (|&) :: (IsStream t, MonadAsync m) => t m a -> (t m a -> t m b) -> t m b
++ (|&.) :: (IsStream t, MonadAsync m) => t m a -> (t m a -> m b) -> m b
++ [rateBuffer] :: Rate -> Int
++ [rateGoal] :: Rate -> Double
++ [rateHigh] :: Rate -> Double
++ [rateLow] :: Rate -> Double
++ adapt :: (IsStream t1, IsStream t2) => t1 m a -> t2 m a
++ ahead :: (IsStream t, MonadAsync m) => t m a -> t m a -> t m a
++ async :: (IsStream t, MonadAsync m) => t m a -> t m a -> t m a
++ avgRate :: IsStream t => Double -> t m a -> t m a
++ constRate :: IsStream t => Double -> t m a -> t m a
++ maxBuffer :: IsStream t => Int -> t m a -> t m a
++ maxRate :: IsStream t => Double -> t m a -> t m a
++ maxThreads :: IsStream t => Int -> t m a -> t m a
++ minRate :: IsStream t => Double -> t m a -> t m a
++ mkAsync :: (IsStream t, MonadAsync m) => t m a -> t m a
++ parallel :: (IsStream t, MonadAsync m) => t m a -> t m a -> t m a
++ rate :: IsStream t => Maybe Rate -> t m a -> t m a
++ serial :: IsStream t => t m a -> t m a -> t m a
++ wAsync :: (IsStream t, MonadAsync m) => t m a -> t m a -> t m a
++ wSerial :: IsStream t => t m a -> t m a -> t m a

# Added
++ delay :: (IsStream t, MonadIO m) => Double -> t m a -> t m a
++ foldMany :: (IsStream t, Monad m) => Fold m a b -> t m a -> t m b
++ intercalate :: (IsStream t, Monad m) => Unfold m b c -> b -> t m b -> t m c
++ intercalateSuffix :: (IsStream t, Monad m) => Unfold m b c -> b -> t m b -> t m c
++ liftInner :: (Monad m, IsStream t, MonadTrans tr, Monad (tr m)) => t m a -> t (tr m) a
++ runReaderT :: (IsStream t, Monad m) => m s -> t (ReaderT s m) a -> t m a
++ runStateT :: Monad m => m s -> SerialT (StateT s m) a -> SerialT m (s, a)

# Removed: documentation moved to streamly-docs module in docs dir
@@@ Streamly.Tutorial

# Deprecated, renamed
~~~ Streamly.Data.Unicode.Stream
@@@ Streamly.Unicode.Stream
# Moved from Streamly.Data.Unicode.Stream
## Behavior changed
++ decodeUtf8 :: (Monad m, IsStream t) => t m Word8 -> t m Char
++ encodeLatin1 :: (IsStream t, Monad m) => t m Char -> t m Word8
++ encodeUtf8 :: (Monad m, IsStream t) => t m Char -> t m Word8
## Unchanged
++ decodeLatin1 :: (IsStream t, Monad m) => t m Word8 -> t m Char

# Added
++ decodeUtf8' :: (Monad m, IsStream t) => t m Word8 -> t m Char
++ encodeLatin1' :: (IsStream t, Monad m) => t m Char -> t m Word8
++ encodeStrings :: (MonadIO m, IsStream t) => (SerialT m Char -> SerialT m Word8) -> t m String -> t m (Array Word8)
++ encodeUtf8' :: (Monad m, IsStream t) => t m Char -> t m Word8
